<cffunction name="init" access="public" returntype="transfer.com.TransferObject" default="transfer.com.TransferObject" hint="Constructor for Transfer class security.User" output="false">
<cfargument name="transfer" type="transfer.com.Transfer" required="true" hint="The Transfer library">
<cfargument name="utility" type="transfer.com.util.Utility" required="true" hint="The Utility object">
<cfargument name="nullable" type="transfer.com.sql.Nullable" required="true" hint="The Nullable lookup object">
<cfargument name="thisObject" type="transfer.com.TransferObject" required="true" hint="What is determined to be the base 'this' object for this TransferObject">
<cfscript>
instance = StructNew();
setThisObject(arguments.thisObject);
setTransfer(arguments.transfer);
setUtility(arguments.utility);
setSystem(createObject("java", "java.lang.System"));
setNullable(arguments.nullable);
setClassName("security.User");
setIsDirty(true);
setIsPersisted(false);
setIsClone(false);
setuserID(getNullable().getNullUUID(getClassName(), "userID"));
setfname("");
setlname("");
setemail("");
setusername("");
setpassword("");
setisActive(false);
setisConfirmed(false);
setcreateDate(Now());
setmodifyDate(Now());
setisDefault(false);
setLoaded(StructNew());
setPermissionisLoaded(true);
setRoleisLoaded(true);
setPermissionCollection(ArrayNew(1));
setPermissionIDCollection(StructNew());
if(StructKeyExists(this, "configure") OR StructKeyExists(variables, "configure"))
{
configure();
}
return this;
</cfscript>
</cffunction>

<cffunction name="equalsTransfer" access="public" returntype="boolean" default="boolean" hint="If an object is persisted, returns true if they are of the same class and same id. If not, returns true if they are the same object." output="false">
<cfargument name="transfer" type="transfer.com.TransferObject" required="true" hint="The TransferObject to test against">
<cfscript>
if(getIsPersisted())
{
if(getClassName() neq arguments.transfer.getClassName())
{
return false;
}
return (getuserID() eq arguments.transfer.getuserID());
}
else
{
return sameTransfer(arguments.transfer);
}
</cfscript>
</cffunction>

<cffunction name="getuserID" access="public" returntype="uuid" default="uuid" hint="Accessor for property userID" output="false">
<cfscript>
return instance.userID;
</cfscript>
</cffunction>

<cffunction name="setuserID" access="public" returntype="void" default="void" hint="Mutator for property userID" output="false">
<cfargument name="userID" type="uuid" required="true" hint="The value to set userID to">
<cfscript>
if(NOT StructKeyExists(instance, "userID") OR getuserID() neq arguments.userID)
{
instance.userID = UCase(arguments.userID);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getfname" access="public" returntype="string" default="string" hint="Accessor for property fname" output="false">
<cfscript>
return instance.fname;
</cfscript>
</cffunction>

<cffunction name="setfname" access="public" returntype="void" default="void" hint="Mutator for property fname" output="false">
<cfargument name="fname" type="string" required="true" hint="The value to set fname to">
<cfscript>
if(NOT StructKeyExists(instance, "fname") OR Compare(getfname(), arguments.fname) neq 0)
{
instance.fname = (arguments.fname);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getlname" access="public" returntype="string" default="string" hint="Accessor for property lname" output="false">
<cfscript>
return instance.lname;
</cfscript>
</cffunction>

<cffunction name="setlname" access="public" returntype="void" default="void" hint="Mutator for property lname" output="false">
<cfargument name="lname" type="string" required="true" hint="The value to set lname to">
<cfscript>
if(NOT StructKeyExists(instance, "lname") OR Compare(getlname(), arguments.lname) neq 0)
{
instance.lname = (arguments.lname);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getemail" access="public" returntype="string" default="string" hint="Accessor for property email" output="false">
<cfscript>
return instance.email;
</cfscript>
</cffunction>

<cffunction name="setemail" access="public" returntype="void" default="void" hint="Mutator for property email" output="false">
<cfargument name="email" type="string" required="true" hint="The value to set email to">
<cfscript>
if(NOT StructKeyExists(instance, "email") OR Compare(getemail(), arguments.email) neq 0)
{
instance.email = (arguments.email);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getusername" access="public" returntype="string" default="string" hint="Accessor for property username" output="false">
<cfscript>
return instance.username;
</cfscript>
</cffunction>

<cffunction name="setusername" access="public" returntype="void" default="void" hint="Mutator for property username" output="false">
<cfargument name="username" type="string" required="true" hint="The value to set username to">
<cfscript>
if(NOT StructKeyExists(instance, "username") OR Compare(getusername(), arguments.username) neq 0)
{
instance.username = (arguments.username);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getpassword" access="public" returntype="string" default="string" hint="Accessor for property password" output="false">
<cfscript>
return instance.password;
</cfscript>
</cffunction>

<cffunction name="setpassword" access="public" returntype="void" default="void" hint="Mutator for property password" output="false">
<cfargument name="password" type="string" required="true" hint="The value to set password to">
<cfscript>
if(NOT StructKeyExists(instance, "password") OR Compare(getpassword(), arguments.password) neq 0)
{
instance.password = (arguments.password);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getisActive" access="public" returntype="boolean" default="boolean" hint="Accessor for property isActive" output="false">
<cfscript>
return instance.isActive;
</cfscript>
</cffunction>

<cffunction name="setisActive" access="public" returntype="void" default="void" hint="Mutator for property isActive" output="false">
<cfargument name="isActive" type="boolean" required="true" hint="The value to set isActive to">
<cfscript>
if(NOT StructKeyExists(instance, "isActive") OR getisActive() neq arguments.isActive)
{
instance.isActive = (arguments.isActive);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getisConfirmed" access="public" returntype="boolean" default="boolean" hint="Accessor for property isConfirmed" output="false">
<cfscript>
return instance.isConfirmed;
</cfscript>
</cffunction>

<cffunction name="setisConfirmed" access="public" returntype="void" default="void" hint="Mutator for property isConfirmed" output="false">
<cfargument name="isConfirmed" type="boolean" required="true" hint="The value to set isConfirmed to">
<cfscript>
if(NOT StructKeyExists(instance, "isConfirmed") OR getisConfirmed() neq arguments.isConfirmed)
{
instance.isConfirmed = (arguments.isConfirmed);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getcreateDate" access="public" returntype="date" default="date" hint="Accessor for property createDate" output="false">
<cfscript>
return instance.createDate;
</cfscript>
</cffunction>

<cffunction name="setcreateDate" access="public" returntype="void" default="void" hint="Mutator for property createDate" output="false">
<cfargument name="createDate" type="date" required="true" hint="The value to set createDate to">
<cfscript>
if(NOT StructKeyExists(instance, "createDate") OR getcreateDate() neq arguments.createDate)
{
instance.createDate = (arguments.createDate);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getmodifyDate" access="public" returntype="date" default="date" hint="Accessor for property modifyDate" output="false">
<cfscript>
return instance.modifyDate;
</cfscript>
</cffunction>

<cffunction name="setmodifyDate" access="public" returntype="void" default="void" hint="Mutator for property modifyDate" output="false">
<cfargument name="modifyDate" type="date" required="true" hint="The value to set modifyDate to">
<cfscript>
if(NOT StructKeyExists(instance, "modifyDate") OR getmodifyDate() neq arguments.modifyDate)
{
instance.modifyDate = (arguments.modifyDate);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getisDefault" access="public" returntype="boolean" default="boolean" hint="Accessor for property isDefault" output="false">
<cfscript>
return instance.isDefault;
</cfscript>
</cffunction>

<cffunction name="setisDefault" access="public" returntype="void" default="void" hint="Mutator for property isDefault" output="false">
<cfargument name="isDefault" type="boolean" required="true" hint="The value to set isDefault to">
<cfscript>
if(NOT StructKeyExists(instance, "isDefault") OR getisDefault() neq arguments.isDefault)
{
instance.isDefault = (arguments.isDefault);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getPermissionisLoaded" access="public" returntype="boolean" default="boolean" hint="Whether or not the composition 'Permission' has been loaded yet" output="false">
<cfscript>
if(NOT StructKeyExists(getLoaded(), "Permission"))
{
setPermissionisLoaded(false);
}
return StructFind(getLoaded(), "Permission");
</cfscript>
</cffunction>

<cffunction name="setPermissionisLoaded" access="private" returntype="void" default="void" hint="Set the loaded state of composition 'arguments.name'" output="false">
<cfargument name="loaded" type="boolean" required="true" hint="Whether or not this composition has been loaded">
<cfscript>
StructInsert(getLoaded(), "Permission", arguments.loaded, true);
</cfscript>
</cffunction>

<cffunction name="loadPermission" access="package" returntype="void" default="void" hint="Lazy load composition 'Permission'" output="false">
<cfif NOT getPermissionisLoaded()>
<cflock name="transfer.load.security.User.Permission.#getSystem().identityHashCode(this)#" timeout="60">
<cfif NOT getPermissionisLoaded()>
<cfscript>
getTransfer().loadManyToMany(getThisObject(), "Permission");
</cfscript>
</cfif>
</cflock>
</cfif>
</cffunction>

<cffunction name="unLoadPermission" access="private" returntype="void" default="void" hint="unload lazy load composition 'Permission'" output="false">
<cfif getPermissionisLoaded()>
<cflock name="transfer.load.security.User.Permission.#getSystem().identityHashCode(this)#" timeout="60">
<cfif getPermissionisLoaded()>
<cfscript>
setPermissionisLoaded(false);
emptyPermission();
</cfscript>
</cfif>
</cflock>
</cfif>
</cffunction>

<cffunction name="getRoleisLoaded" access="public" returntype="boolean" default="boolean" hint="Whether or not the composition 'Role' has been loaded yet" output="false">
<cfscript>
if(NOT StructKeyExists(getLoaded(), "Role"))
{
setRoleisLoaded(false);
}
return StructFind(getLoaded(), "Role");
</cfscript>
</cffunction>

<cffunction name="setRoleisLoaded" access="private" returntype="void" default="void" hint="Set the loaded state of composition 'arguments.name'" output="false">
<cfargument name="loaded" type="boolean" required="true" hint="Whether or not this composition has been loaded">
<cfscript>
StructInsert(getLoaded(), "Role", arguments.loaded, true);
</cfscript>
</cffunction>

<cffunction name="loadRole" access="package" returntype="void" default="void" hint="Lazy load composition 'Role'" output="false">
<cfif NOT getRoleisLoaded()>
<cflock name="transfer.load.security.User.Role.#getSystem().identityHashCode(this)#" timeout="60">
<cfif NOT getRoleisLoaded()>
<cfscript>
getTransfer().loadManyToOne(getThisObject(), "Role");
</cfscript>
</cfif>
</cflock>
</cfif>
</cffunction>

<cffunction name="unLoadRole" access="private" returntype="void" default="void" hint="unload lazy load composition 'Role'" output="false">
<cfif getRoleisLoaded()>
<cflock name="transfer.load.security.User.Role.#getSystem().identityHashCode(this)#" timeout="60">
<cfif getRoleisLoaded()>
<cfscript>
setRoleisLoaded(false);
StructDelete(instance, "Role");
</cfscript>
</cfif>
</cflock>
</cfif>
</cffunction>

<cffunction name="setMemento" access="public" returntype="void" default="void" hint="set the state of this object from a memento" output="false">
<cfargument name="memento" type="struct" required="true" hint="the memento to set the state with">
<cfscript>
var composite = 0;
if(NOT getIsPersisted())
{
setuserID(StructFind(arguments.memento, "userID"));
}
setPropertyMemento(arguments.memento);
setRoleisLoaded(false);
if(StructKeyExists(arguments.memento, "Role"))
{
composite = StructFind(arguments.memento, "Role");
}
else
{
composite = StructNew();
}
setRoleMemento(composite);
setPermissionisLoaded(false);
</cfscript>
</cffunction>

<cffunction name="setPropertyMemento" access="public" returntype="void" default="void" hint="set the Property state of this object with a memento" output="false">
<cfargument name="memento" type="struct" required="true" hint="the memento to set the state with">
<cfscript>
setfname(StructFind(arguments.memento, "fname"));
setlname(StructFind(arguments.memento, "lname"));
setemail(StructFind(arguments.memento, "email"));
setusername(StructFind(arguments.memento, "username"));
setpassword(StructFind(arguments.memento, "password"));
setisActive(StructFind(arguments.memento, "isActive"));
setisConfirmed(StructFind(arguments.memento, "isConfirmed"));
setcreateDate(StructFind(arguments.memento, "createDate"));
setmodifyDate(StructFind(arguments.memento, "modifyDate"));
setisDefault(StructFind(arguments.memento, "isDefault"));
</cfscript>
</cffunction>

<cffunction name="setRoleMemento" access="public" returntype="void" default="void" hint="set the state of composition manytoone 'Role'" output="false">
<cfargument name="memento" type="struct" required="true" hint="the memento to set the state with">
<cfscript>
var composite = 0;
if(StructIsEmpty(arguments.memento))
{
removeRole();
}
else
{
composite = getComposite("security.Role", arguments.memento, "roleID");
setRole(composite);
}
</cfscript>
</cffunction>

<cffunction name="setPermissionMemento" access="public" returntype="void" default="void" hint="set the state of composition manytomany 'Permission'" output="false">
<cfargument name="memento" type="array" required="true" hint="the memento to set the state with">
<cfscript>
var collection = ArrayNew(1);
var idcollection = StructNew();
var counter = 0;
var len = 0;
var item = 0;
var composite = 0;
</cfscript>
<cflock name="transfer.security.User.Permission.#getuserID()#" timeout="60">
<cfscript>
len = ArrayLen(arguments.memento);
for(counter = 1; counter lte len; counter = counter + 1)
{
composite = arguments.memento[counter];
StructInsert(composite, "parentUser_transferObject", getThisObject());
item = getComposite("security.Permission", composite, "permissionID");
StructInsert(idcollection, "pk:" & item.getpermissionID(), 1, true);
StructInsert(idcollection, "obj:" & getSystem().identityHashCode(item), 1, true);
arrayAppend(collection, item);
}
setPermissionIDCollection(idcollection);
setPermissionCollection(collection);
setPermissionisLoaded(true);
</cfscript>
</cflock>
</cffunction>

<cffunction name="getMemento" access="public" returntype="struct" default="struct" hint="Returns the memento for all non-lazy members of this object" output="false">
<cfscript>
var memento = createObject("java", "java.util.HashMap").init();
StructInsert(memento, "userID", getuserID());
StructInsert(memento, "transfer_isDirty", getIsDirty());
StructInsert(memento, "transfer_isPersisted", getIsPersisted());
StructInsert(memento, "transfer_isProxied", false);
StructAppend(memento, getPropertyMemento());
StructInsert(memento, "Role", getRoleMemento());
return memento;
</cfscript>
</cffunction>

<cffunction name="getPropertyMemento" access="public" returntype="struct" default="struct" hint="returns the memento for properties" output="false">
<cfscript>
var memento = createObject("java", "java.util.HashMap").init();
StructInsert(memento, "fname", getfname());
StructInsert(memento, "lname", getlname());
StructInsert(memento, "email", getemail());
StructInsert(memento, "username", getusername());
StructInsert(memento, "password", getpassword());
StructInsert(memento, "isActive", getisActive());
StructInsert(memento, "isConfirmed", getisConfirmed());
StructInsert(memento, "createDate", getcreateDate());
StructInsert(memento, "modifyDate", getmodifyDate());
StructInsert(memento, "isDefault", getisDefault());
return memento;
</cfscript>
</cffunction>

<cffunction name="getRoleMemento" access="public" returntype="struct" default="struct" hint="returns the memento for manytoone Role" output="false">
<cfscript>
var memento = createObject("java", "java.util.HashMap").init();
if(hasRole())
{
memento = getRole().getMemento();
}
return memento;
</cfscript>
</cffunction>

<cffunction name="getPermissionMemento" access="public" returntype="array" default="array" hint="returns the memento for the manytomany Permission" output="false">
<cfscript>
var memento = createObject("java", "java.util.ArrayList").init();
var iterator = getPermissionIterator();
var item = 0;
while(iterator.hasNext())
{
item = iterator.next();
ArrayAppend(memento, item.getMemento());
}
return memento;
</cfscript>
</cffunction>

<cffunction name="copyValuesTo" access="public" returntype="void" default="void" hint="Copies the values of this object to one of the same class" output="false">
<cfargument name="transfer" type="transfer.com.TransferObject" required="true" hint="The object to copy values to">
<cfscript>
if(arguments.transfer.getClassName() neq "security.User")
{
throw("InvalidTransferClassException","The supplied Transfer class was not the one specified in the configuration file ","The Transfer class of '#arguments.transfer.getClassName()#' does not match the expected class of 'security.User'");
}
arguments.transfer.setMemento(getMemento());
if(getPermissionisLoaded())
{
arguments.transfer.setPermissionMemento(getPermissionMemento());
}
</cfscript>
</cffunction>

<cffunction name="getRole" access="public" returntype="transfer.com.TransferObject" default="transfer.com.TransferObject" hint="Accessor for Role, security.Role" output="false">
<cfscript>
if(NOT getRoleisLoaded())
{
loadRole();
}
if(NOT structKeyExists(instance, "Role"))
{
throw("ManyToOneNotSetException","A ManyToOne TransferObject has not been initialised.","In TransferObject 'security.User' manytoone 'security.Role' does not exist, when calling getRole()");
}
return instance.Role;
</cfscript>
</cffunction>

<cffunction name="setRole" access="public" returntype="void" default="void" hint="Mutator for Role, security.Role" output="false">
<cfargument name="transfer" type="transfer.com.TransferObject" required="true" hint="The security.Role to set">
<cfscript>
if(arguments.transfer.getClassName() neq "security.Role")
{
throw("InvalidTransferClassException","The supplied Transfer class was not the one specified in the configuration file ","The Transfer class of '#arguments.transfer.getClassName()#' does not match the expected class of 'security.Role'");
}
if((NOT getRoleisLoaded()) OR (NOT (StructKeyExists(instance, "Role") AND getRole().equalsTransfer(arguments.transfer))))
{
instance.Role = arguments.transfer;
setIsDirty(true);
setRoleisLoaded(true);
}
</cfscript>
</cffunction>

<cffunction name="hasRole" access="public" returntype="boolean" default="boolean" hint="Whether or not this object contains a security.Role" output="false">
<cfscript>
if(NOT getRoleisLoaded())
{
loadRole();
}
return StructKeyExists(instance,"Role");
</cfscript>
</cffunction>

<cffunction name="removeRole" access="public" returntype="void" default="void" hint="remove the instance of security.Role" output="false">
<cfscript>
if(NOT getRoleisLoaded() OR hasRole())
{
StructDelete(instance,"Role");
setIsDirty(true);
setRoleisLoaded(true);
}
</cfscript>
</cffunction>

<cffunction name="getPermissionCollection" access="private" returntype="array" default="array" hint="Accessor for the internal collection for Permission" output="false">
<cfscript>
return instance.Permission;
</cfscript>
</cffunction>

<cffunction name="setPermissionCollection" access="private" returntype="void" default="void" hint="Mutator for the internal collection for Permission" output="false">
<cfargument name="Permission" type="array" required="true" hint="The array to set">
<cfscript>
instance.Permission = arguments.Permission;
</cfscript>
</cffunction>

<cffunction name="getPermissionIDCollection" access="private" returntype="struct" default="struct" hint="Accessor for internal id collection, for faster contain*() calls" output="false">
<cfreturn instance.PermissionIDCollection />
</cffunction>

<cffunction name="setPermissionIDCollection" access="private" returntype="void" default="void" hint="Mutator for internal id collection, for faster contain*() calls" output="false">
<cfargument name="collection" type="struct" required="true" hint="the key for the id to be stored under">
<cfset instance.PermissionIDCollection = arguments.collection />
</cffunction>

<cffunction name="getPermission" access="public" returntype="transfer.com.TransferObject" default="transfer.com.TransferObject" hint="Returns the security.Permission object at the given index in the array" output="false">
<cfargument name="index" type="numeric" required="true" hint="The index in the array to retrieve">
<cfscript>
if(NOT getPermissionisLoaded())
{
loadPermission();
}
return getPermissionCollection().get(JavaCast("int", arguments.index - 1));
</cfscript>
</cffunction>

<cffunction name="getPermissionArray" access="public" returntype="array" default="array" hint="returns the entire array of security.Permission" output="false">
<cfscript>
var array = ArrayNew(1);
if(NOT getPermissionisLoaded())
{
loadPermission();
}
array.addAll(getPermissionCollection());
return array;
</cfscript>
</cffunction>

<cffunction name="getPermissionIterator" access="public" returntype="any" default="any" hint="return a java.util.Iterator of security.Permission objects" output="false">
<cfscript>
if(NOT getPermissionisLoaded())
{
loadPermission();
}
return getPermissionArray().iterator();
</cfscript>
</cffunction>

<cffunction name="containsPermission" access="public" returntype="boolean" default="boolean" hint="If this array contains a particular instance of security.Permission" output="false">
<cfargument name="object" type="transfer.com.TransferObject" required="true" hint="The object to look for">
<cfargument name="pkCheckOnly" type="boolean" required="false" hint="Expert/Transfer use only: only checks primary keys" default="false">
<cfscript>
var composite = 0;
var array = getPermissionArray();
var counter = 1;
var len = 0;
var check = false;
var idcollection = getPermissionidCollection();
if(arguments.object.getClassName() neq "security.Permission")
{
throw("InvalidTransferClassException","The supplied Transfer class was not the one specified in the configuration file ","The Transfer class of '#arguments.object.getClassName()#' does not match the expected class of 'security.Permission'");
}
if(arguments.object.getIsPersisted() AND StructKeyExists(idcollection, "pk:" & arguments.object.getpermissionID()))
{
return true;
}
if(arguments.pkCheckOnly)
{
return false;
}
if(StructKeyExists(idcollection, "obj:" & getSystem().identityHashCode(arguments.object)))
{
check = true;
}
if(NOT check)
{
len = ArrayLen(array);
for(; counter lte len; counter = counter + 1)
{
composite = array[counter];
if(composite.equalsTransfer(arguments.object))
{
check = true;
break;
}
}
}
if(check AND arguments.object.getIsPersisted())
{
StructInsert(idcollection, "pk:" & arguments.object.getpermissionID(), 1, true);
}
return check;
</cfscript>
</cffunction>

<cffunction name="findPermission" access="public" returntype="numeric" default="numeric" hint="Find the index number that the given object is at in the Array. Returns -1 if it can't be found.'" output="false">
<cfargument name="object" type="transfer.com.TransferObject" required="true" hint="The object to search for">
<cfscript>
var iterator = 0;
var composite = 0;
var counter = 0;
if(NOT getPermissionisLoaded())
{
loadPermission();
}
iterator = getPermissionCollection().iterator();
if(arguments.object.getClassName() neq "security.Permission")
{
throw("InvalidTransferClassException","The supplied Transfer class was not the one specified in the configuration file ","The Transfer class of '#arguments.object.getClassName()#' does not match the expected class of 'security.Permission'");
}
while(iterator.hasNext())
{
composite = iterator.next();
counter = counter + 1;
if(composite.equalsTransfer(arguments.object))
{
return counter;
}
}
return -1;
</cfscript>
</cffunction>

<cffunction name="emptyPermission" access="public" returntype="void" default="void" hint="empty the collection, with no change to loading'" output="false">
<cfscript>
ArrayClear(getPermissionCollection());
StructClear(getPermissionIDCollection());
</cfscript>
</cffunction>

<cffunction name="addPermission" access="public" returntype="void" default="void" hint="Add an object of type security.Permission to the array" output="false">
<cfargument name="object" type="transfer.com.TransferObject" required="true" hint="The object to add">
<cflock name="transfer.security.User.Permission.#getuserID()#" timeout="60">
<cfscript>
if(arguments.object.getClassName() neq "security.Permission")
{
throw("InvalidTransferClassException","The supplied Transfer class was not the one specified in the configuration file ","The Transfer class of '#arguments.object.getClassName()#' does not match the expected class of 'security.Permission'");
}
if(NOT getPermissionisLoaded())
{
loadPermission();
}
if(arguments.object.getIsPersisted())
{
StructInsert(getPermissionIDCollection(), "pk:" & arguments.object.getpermissionID(), 1, true);
}
StructInsert(getPermissionIDCollection(), "obj:" & getSystem().identityHashCode(arguments.object), 1, true);
ArrayAppend(getPermissionCollection(), arguments.object);
setIsDirty(true);
</cfscript>
</cflock>
</cffunction>

<cffunction name="removePermission" access="public" returntype="void" default="void" hint="remove an object of type security.Permission from the array" output="false">
<cfargument name="object" type="transfer.com.TransferObject" required="true" hint="the object to remove">
<cfscript>
var iterator = 0;
var composite = 0;
if(arguments.object.getClassName() neq "security.Permission")
{
throw("InvalidTransferClassException","The supplied Transfer class was not the one specified in the configuration file ","The Transfer class of '#arguments.object.getClassName()#' does not match the expected class of 'security.Permission'");
}
</cfscript>
<cflock name="transfer.security.User.Permission.#getuserID()#" timeout="60">
<cfscript>
if(NOT getPermissionisLoaded())
{
loadPermission();
}
iterator = getPermissionCollection().iterator();
while(iterator.hasNext())
{
composite = iterator.next();
if(composite.equalsTransfer(arguments.object))
{
iterator.remove();
if(arguments.object.getIsPersisted())
{
StructDelete(getPermissionIDCollection(), "pk:" & arguments.object.getpermissionID());
}
StructDelete(getPermissionIDCollection(), "obj:" & getSystem().identityHashCode(arguments.object));
setIsDirty(true);
return;
}
}
</cfscript>
</cflock>
</cffunction>

<cffunction name="clearPermission" access="public" returntype="void" default="void" hint="Clear all the elements from the array" output="false">
<cflock name="transfer.security.User.Permission.#getuserID()#" timeout="60">
<cfscript>
emptyPermission();
setIsDirty(true);
setPermissionisLoaded(true);
</cfscript>
</cflock>
</cffunction>

<cffunction name="sortPermission" access="public" returntype="void" default="void" hint="Sort all elements in the array Permission" output="false">
<cflock name="transfer.security.User.Permission.#getuserID()#" timeout="60">
<cfscript>
if(NOT arrayisEmpty(getPermissionCollection()))
{
setPermissionCollection(getUtility().quickSort(getPermissionCollection(), PermissionComparator));
}
</cfscript>
</cflock>
</cffunction>

<cffunction name="PermissionComparator" access="private" returntype="numeric" default="numeric" hint="The Comparator HOF for sorting" output="false">
<cfargument name="object1" type="transfer.com.TransferObject" required="true" hint="object one">
<cfargument name="object2" type="transfer.com.TransferObject" required="true" hint="object two">
<cfscript>
if(arguments.object1.getpermissionID() lt arguments.object2.getpermissionID())
{
return -1;
}
else if(arguments.object1.getpermissionID() gt arguments.object2.getpermissionID())
{
return 1;
}
return 0;
</cfscript>
</cffunction>

<cffunction name="validateCacheState" access="package" returntype="boolean" default="boolean" hint="if this object is cached, then validate that all it's composites are cached too" output="false">
<cfscript>
var iterator = 0;
var item = 0;
if(getIsPersisted() AND NOT getTransfer().validateIsCached(getThisObject()))
{
return true;
}
if(getRoleisLoaded() AND hasRole())
{
item = getRole();
if(item.getIsClone() OR NOT getTransfer().validateIsCached(item))
{
return false;
}
}
if(getPermissionisLoaded())
{
iterator = getPermissioniterator();
while(iterator.hasNext())
{
item = iterator.next();
if(item.getIsClone() OR NOT getTransfer().validateIsCached(item))
{
return false;
}
}
}
return true;
</cfscript>
</cffunction>

<cffunction name="actionAfterCreateTransferEvent" access="public" returntype="void" default="void" hint="Observer action method for when creates occur" output="false">
<cfargument name="event" type="transfer.com.events.TransferEvent" required="true" hint="The Transfer Event Object">
<cfscript>
var className = arguments.event.getTransferObject().getClassName();
</cfscript>
</cffunction>

<cffunction name="actionAfterDeleteTransferEvent" access="public" returntype="void" default="void" hint="Observer action method for when deletes occur" output="false">
<cfargument name="event" type="transfer.com.events.TransferEvent" required="true" hint="The Transfer Event Object">
<cfscript>
var className = arguments.event.getTransferObject().getClassName();
if(className eq "security.Permission")
{
if(getPermissionIsLoaded())
{
while(containsPermission(arguments.event.getTransferObject()))
{
removePermission(arguments.event.getTransferObject());
}
}
}
if(className eq "security.Role")
{
if(getRoleIsLoaded() AND hasRole() AND getRole().equalsTransfer(arguments.event.getTransferObject()))
{
removeRole(arguments.event.getTransferObject());
}
}
</cfscript>
</cffunction>

<cffunction name="actionAfterUpdateTransferEvent" access="public" returntype="void" default="void" hint="Observer method action for when updates occur" output="false">
<cfargument name="event" type="transfer.com.events.TransferEvent" required="true" hint="The Transfer Event Object">
<cfscript>
var className = arguments.event.getTransferObject().getClassName();
switch(arguments.event.getTransferObject().getClassName())
{
case "security.Permission":
if(getPermissionIsLoaded() AND containsPermission(arguments.event.getTransferObject()))
{
sortPermission();
}
break;
}
</cfscript>
</cffunction>

<cffunction name="actionAfterDiscardTransferEvent" access="public" returntype="void" default="void" hint="Observer action method for when discards occur" output="false">
<cfargument name="event" type="transfer.com.events.TransferEvent" required="true" hint="The Transfer Event Object">
<cfscript>
var discard = false;
var className = arguments.event.getTransferObject().getClassName();
if(className eq "security.Permission")
{
if(getPermissionIsLoaded() AND containsPermission(arguments.event.getTransferObject()))
{
if(getPermissionisLoaded())
{
unloadPermission();
}
}
}
if(className eq "security.Role")
{
if(getRoleIsLoaded() AND hasRole() AND getRole().equalsTransfer(arguments.event.getTransferObject()))
{
if(getRoleisLoaded())
{
unloadRole();
}
}
}
if(discard)
{
getTransfer().discard(getThisObject());
}
</cfscript>
</cffunction>


