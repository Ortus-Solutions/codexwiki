<cffunction name="init" access="public" returntype="transfer.com.TransferObject" default="transfer.com.TransferObject" hint="Constructor for Transfer class wiki.CustomHTML" output="false">
<cfargument name="transfer" type="transfer.com.Transfer" required="true" hint="The Transfer library">
<cfargument name="utility" type="transfer.com.util.Utility" required="true" hint="The Utility object">
<cfargument name="nullable" type="transfer.com.sql.Nullable" required="true" hint="The Nullable lookup object">
<cfargument name="thisObject" type="transfer.com.TransferObject" required="true" hint="What is determined to be the base 'this' object for this TransferObject">
<cfscript>
instance = StructNew();
setThisObject(arguments.thisObject);
setTransfer(arguments.transfer);
setUtility(arguments.utility);
setSystem(createObject("java", "java.lang.System"));
setNullable(arguments.nullable);
setClassName("wiki.CustomHTML");
setIsDirty(true);
setIsPersisted(false);
setIsClone(false);
setcustomHTML_id(getNullable().getNullUUID(getClassName(), "customHTML_id"));
setbeforeHeadEnd("");
setafterBodyStart("");
setbeforeBodyEnd("");
setafterSideBar("");
setbeforeSideBar("");
setmodifyDate(Now());
setLoaded(StructNew());
if(StructKeyExists(this, "configure") OR StructKeyExists(variables, "configure"))
{
configure();
}
return this;
</cfscript>
</cffunction>

<cffunction name="equalsTransfer" access="public" returntype="boolean" default="boolean" hint="If an object is persisted, returns true if they are of the same class and same id. If not, returns true if they are the same object." output="false">
<cfargument name="transfer" type="transfer.com.TransferObject" required="true" hint="The TransferObject to test against">
<cfscript>
if(getIsPersisted())
{
if(getClassName() neq arguments.transfer.getClassName())
{
return false;
}
return (getcustomHTML_id() eq arguments.transfer.getcustomHTML_id());
}
else
{
return sameTransfer(arguments.transfer);
}
</cfscript>
</cffunction>

<cffunction name="getcustomHTML_id" access="public" returntype="uuid" default="uuid" hint="Accessor for property customHTML_id" output="false">
<cfscript>
return instance.customHTML_id;
</cfscript>
</cffunction>

<cffunction name="setcustomHTML_id" access="public" returntype="void" default="void" hint="Mutator for property customHTML_id" output="false">
<cfargument name="customHTML_id" type="uuid" required="true" hint="The value to set customHTML_id to">
<cfscript>
if(NOT StructKeyExists(instance, "customHTML_id") OR getcustomHTML_id() neq arguments.customHTML_id)
{
instance.customHTML_id = UCase(arguments.customHTML_id);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getbeforeHeadEnd" access="public" returntype="string" default="string" hint="Accessor for property beforeHeadEnd" output="false">
<cfscript>
return instance.beforeHeadEnd;
</cfscript>
</cffunction>

<cffunction name="setbeforeHeadEnd" access="public" returntype="void" default="void" hint="Mutator for property beforeHeadEnd" output="false">
<cfargument name="beforeHeadEnd" type="string" required="true" hint="The value to set beforeHeadEnd to">
<cfscript>
if(NOT StructKeyExists(instance, "beforeHeadEnd") OR Compare(getbeforeHeadEnd(), arguments.beforeHeadEnd) neq 0)
{
instance.beforeHeadEnd = (arguments.beforeHeadEnd);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getafterBodyStart" access="public" returntype="string" default="string" hint="Accessor for property afterBodyStart" output="false">
<cfscript>
return instance.afterBodyStart;
</cfscript>
</cffunction>

<cffunction name="setafterBodyStart" access="public" returntype="void" default="void" hint="Mutator for property afterBodyStart" output="false">
<cfargument name="afterBodyStart" type="string" required="true" hint="The value to set afterBodyStart to">
<cfscript>
if(NOT StructKeyExists(instance, "afterBodyStart") OR Compare(getafterBodyStart(), arguments.afterBodyStart) neq 0)
{
instance.afterBodyStart = (arguments.afterBodyStart);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getbeforeBodyEnd" access="public" returntype="string" default="string" hint="Accessor for property beforeBodyEnd" output="false">
<cfscript>
return instance.beforeBodyEnd;
</cfscript>
</cffunction>

<cffunction name="setbeforeBodyEnd" access="public" returntype="void" default="void" hint="Mutator for property beforeBodyEnd" output="false">
<cfargument name="beforeBodyEnd" type="string" required="true" hint="The value to set beforeBodyEnd to">
<cfscript>
if(NOT StructKeyExists(instance, "beforeBodyEnd") OR Compare(getbeforeBodyEnd(), arguments.beforeBodyEnd) neq 0)
{
instance.beforeBodyEnd = (arguments.beforeBodyEnd);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getafterSideBar" access="public" returntype="string" default="string" hint="Accessor for property afterSideBar" output="false">
<cfscript>
return instance.afterSideBar;
</cfscript>
</cffunction>

<cffunction name="setafterSideBar" access="public" returntype="void" default="void" hint="Mutator for property afterSideBar" output="false">
<cfargument name="afterSideBar" type="string" required="true" hint="The value to set afterSideBar to">
<cfscript>
if(NOT StructKeyExists(instance, "afterSideBar") OR Compare(getafterSideBar(), arguments.afterSideBar) neq 0)
{
instance.afterSideBar = (arguments.afterSideBar);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getbeforeSideBar" access="public" returntype="string" default="string" hint="Accessor for property beforeSideBar" output="false">
<cfscript>
return instance.beforeSideBar;
</cfscript>
</cffunction>

<cffunction name="setbeforeSideBar" access="public" returntype="void" default="void" hint="Mutator for property beforeSideBar" output="false">
<cfargument name="beforeSideBar" type="string" required="true" hint="The value to set beforeSideBar to">
<cfscript>
if(NOT StructKeyExists(instance, "beforeSideBar") OR Compare(getbeforeSideBar(), arguments.beforeSideBar) neq 0)
{
instance.beforeSideBar = (arguments.beforeSideBar);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getmodifyDate" access="public" returntype="date" default="date" hint="Accessor for property modifyDate" output="false">
<cfscript>
return instance.modifyDate;
</cfscript>
</cffunction>

<cffunction name="setmodifyDate" access="public" returntype="void" default="void" hint="Mutator for property modifyDate" output="false">
<cfargument name="modifyDate" type="date" required="true" hint="The value to set modifyDate to">
<cfscript>
if(NOT StructKeyExists(instance, "modifyDate") OR getmodifyDate() neq arguments.modifyDate)
{
instance.modifyDate = (arguments.modifyDate);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="setMemento" access="public" returntype="void" default="void" hint="set the state of this object from a memento" output="false">
<cfargument name="memento" type="struct" required="true" hint="the memento to set the state with">
<cfscript>
var composite = 0;
if(NOT getIsPersisted())
{
setcustomHTML_id(StructFind(arguments.memento, "customHTML_id"));
}
setPropertyMemento(arguments.memento);
</cfscript>
</cffunction>

<cffunction name="setPropertyMemento" access="public" returntype="void" default="void" hint="set the Property state of this object with a memento" output="false">
<cfargument name="memento" type="struct" required="true" hint="the memento to set the state with">
<cfscript>
setbeforeHeadEnd(StructFind(arguments.memento, "beforeHeadEnd"));
setafterBodyStart(StructFind(arguments.memento, "afterBodyStart"));
setbeforeBodyEnd(StructFind(arguments.memento, "beforeBodyEnd"));
setafterSideBar(StructFind(arguments.memento, "afterSideBar"));
setbeforeSideBar(StructFind(arguments.memento, "beforeSideBar"));
setmodifyDate(StructFind(arguments.memento, "modifyDate"));
</cfscript>
</cffunction>

<cffunction name="getMemento" access="public" returntype="struct" default="struct" hint="Returns the memento for all non-lazy members of this object" output="false">
<cfscript>
var memento = createObject("java", "java.util.HashMap").init();
StructInsert(memento, "customHTML_id", getcustomHTML_id());
StructInsert(memento, "transfer_isDirty", getIsDirty());
StructInsert(memento, "transfer_isPersisted", getIsPersisted());
StructInsert(memento, "transfer_isProxied", false);
StructAppend(memento, getPropertyMemento());
return memento;
</cfscript>
</cffunction>

<cffunction name="getPropertyMemento" access="public" returntype="struct" default="struct" hint="returns the memento for properties" output="false">
<cfscript>
var memento = createObject("java", "java.util.HashMap").init();
StructInsert(memento, "beforeHeadEnd", getbeforeHeadEnd());
StructInsert(memento, "afterBodyStart", getafterBodyStart());
StructInsert(memento, "beforeBodyEnd", getbeforeBodyEnd());
StructInsert(memento, "afterSideBar", getafterSideBar());
StructInsert(memento, "beforeSideBar", getbeforeSideBar());
StructInsert(memento, "modifyDate", getmodifyDate());
return memento;
</cfscript>
</cffunction>

<cffunction name="copyValuesTo" access="public" returntype="void" default="void" hint="Copies the values of this object to one of the same class" output="false">
<cfargument name="transfer" type="transfer.com.TransferObject" required="true" hint="The object to copy values to">
<cfscript>
if(arguments.transfer.getClassName() neq "wiki.CustomHTML")
{
throw("InvalidTransferClassException","The supplied Transfer class was not the one specified in the configuration file ","The Transfer class of '#arguments.transfer.getClassName()#' does not match the expected class of 'wiki.CustomHTML'");
}
arguments.transfer.setMemento(getMemento());
</cfscript>
</cffunction>

<cffunction name="validateCacheState" access="package" returntype="boolean" default="boolean" hint="if this object is cached, then validate that all it's composites are cached too" output="false">
<cfscript>
var iterator = 0;
var item = 0;
if(getIsPersisted() AND NOT getTransfer().validateIsCached(getThisObject()))
{
return true;
}
return true;
</cfscript>
</cffunction>

<cffunction name="actionAfterCreateTransferEvent" access="public" returntype="void" default="void" hint="Observer action method for when creates occur" output="false">
<cfargument name="event" type="transfer.com.events.TransferEvent" required="true" hint="The Transfer Event Object">
<cfscript>
var className = arguments.event.getTransferObject().getClassName();
</cfscript>
</cffunction>

<cffunction name="actionAfterDeleteTransferEvent" access="public" returntype="void" default="void" hint="Observer action method for when deletes occur" output="false">
<cfargument name="event" type="transfer.com.events.TransferEvent" required="true" hint="The Transfer Event Object">
<cfscript>
var className = arguments.event.getTransferObject().getClassName();
</cfscript>
</cffunction>

<cffunction name="actionAfterUpdateTransferEvent" access="public" returntype="void" default="void" hint="Observer method action for when updates occur" output="false">
<cfargument name="event" type="transfer.com.events.TransferEvent" required="true" hint="The Transfer Event Object">
<cfscript>
var className = arguments.event.getTransferObject().getClassName();
</cfscript>
</cffunction>

<cffunction name="actionAfterDiscardTransferEvent" access="public" returntype="void" default="void" hint="Observer action method for when discards occur" output="false">
<cfargument name="event" type="transfer.com.events.TransferEvent" required="true" hint="The Transfer Event Object">
<cfscript>
var discard = false;
var className = arguments.event.getTransferObject().getClassName();
if(discard)
{
getTransfer().discard(getThisObject());
}
</cfscript>
</cffunction>


